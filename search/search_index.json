{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Homepage","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#code-annotation-examples","title":"Code Annotation Examples","text":""},{"location":"#codeblocks","title":"Codeblocks","text":"<p>Some <code>code</code> goes here.</p>"},{"location":"#plain-codeblock","title":"Plain codeblock","text":"<p>A plain codeblock:</p> <pre><code>Some code here\ndef myfunction()\n// some comment\n</code></pre>"},{"location":"#code-for-a-specific-language","title":"Code for a specific language","text":"<p>Some more code with the <code>py</code> at the start:</p> <pre><code>import tensorflow as tf\ndef whatever()\n</code></pre>"},{"location":"#with-a-title","title":"With a title","text":"bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#with-line-numbers","title":"With line numbers","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#highlighting-lines","title":"Highlighting lines","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#icons-and-emojs","title":"Icons and Emojs","text":""},{"location":"philosophy/","title":"Software Engineering Philosophy","text":"<p>This section outlines the core principles guiding how we design, implement, and maintain software. These principles exist to reduce ambiguity, prevent architectural drift, and ensure long-term maintainability.</p>"},{"location":"philosophy/#core-values","title":"Core Values","text":"<p>Explicit is always better than implicit</p> <p>Code should leave no room for assumptions. Always favor clarity over cleverness. Implicit behavior must be documented and justified when unavoidable.</p> <p>Descriptive naming is better than short-hand</p> <p>Names should describe what something does or represents, even if it means typing more. Abbreviations are acceptable only when they are universally understood, unambiguous and or defined in documentation.</p> <p>Consistency is king</p> <p>Inconsistent code is harder to maintain than slow code. Matching the existing code style is crucial. Local consistency within a module is preferable to global inconsistency across the codebase.</p> <p>Fail fast and prefer early returns over deeply nested conditionals</p> <p>Guard against invalid states and exit as soon as a failure is detected. This keeps control flow flat, readable, and easier to reason about.</p> <p>Test edge-cases early</p> <p>If a function can fail, make it fail during development, not in production. Use assertions, debug-only checks and logging generously where appropriate.</p> <p>Prioritize runtime performance</p> <p>Every design choice should consider its impact on real-time execution. Performance is not an afterthought \u2014 it's a primary goal, especially in hot code-paths.</p> <p>Optimize, optimize, optimize</p> <p>Focus optimization efforts on performance-critical and hot code-paths. Non-critical code should prioritize readability and correctness over micro-optimizations.</p> <p>Minimal state, maximal clarity</p> <p>Avoid unnecessary shared or mutable state. Favor local variables and or shared immutability where possible - const-correctness is key.</p> <p>Be predictable and deterministic</p> <p>Code should behave as expected without surprises. Avoid magic literals, hidden side-effects, global state dependencies, and undocumented behavior.</p> <p>Zero-cost abstractions</p> <p>Abstractions must not introduce runtime overhead. If an abstraction costs extra, it must be justified by a measurable and documented benefit.</p> <p>Avoid clever one-liners</p> <p>Readability trumps cleverness. If a trick saves a few keystrokes but hides intent, do not use it.</p> <p>Never nest</p> <p>Nesting types is the root of all evil, unless kept private, tightly scoped, or for a thin configuration struct.</p> <p>Never ever use snake case</p> <p>we_really_really_hate_snake_case!</p> <p>Quality through iteration</p> <p>Improvements are driven by feedback, peer review, and refactoring. Code quality is treated as a continuous process, not a one-time milestone.</p>"},{"location":"philosophy/#design-and-architecture-principles","title":"Design and Architecture Principles","text":"<p>Simplicity beats generality</p> <p>Solve the current problem well before designing for hypothetical future use-cases. Over-generalization increases complexity and maintenance cost.</p> <p>Prefer composition over inheritance</p> <p>Composition provides clearer ownership, better testability, and fewer implicit behaviors than deep inheritance hierarchies.</p> <p>Ownership must be obvious</p> <p>Resource ownership and lifetime must be clear from the API alone. If ownership is non-obvious, the design is wrong or under-documented.</p> <p>APIs are contracts</p> <p>Public interfaces must be stable, well-documented, and difficult to misuse. Breaking changes require explicit justification and coordination.</p>"},{"location":"philosophy/#decision-considerations","title":"Decision Considerations","text":"<p>When making engineering or architectural decisions, consider:</p> <ol> <li>The impact on readability and long-term maintenance.</li> <li>Alignment with existing architecture, conventions and standards.</li> <li>Technical trade-offs and future implications considering the project's roadmap.</li> <li>Risk, complexity, scalability, and testing cost</li> <li>Failure modes and debuggability.</li> </ol>"},{"location":"philosophy/#software-expectations","title":"Software Expectations","text":"<ul> <li>Code must be testable and demonstrably correct.</li> <li>Peer-review is strongly encouraged.</li> <li>Documentation accompanies new systems and or architectural decisions.</li> <li>Breaking code may not be committed to default branches (<code>master</code>/<code>main</code>).</li> </ul>"},{"location":"philosophy/#continuous-improvement","title":"Continuous Improvement","text":"<p>Intricate Dev Team's standards are updated as our needs evolve alongside our projects and their requirements. Suggestions for changes are welcome and should be proposed appropriately and discussed collaboratively.</p>"},{"location":"project/build-configurations/","title":"Build Configurations","text":"<p>This section lists all of Intricate's build configurations and their intended purposes.</p>"},{"location":"project/build-configurations/#configurations","title":"Configurations","text":"<p>Intricate has <code>4</code> different build configurations which can be selected from inside Visual Studio.</p> Configuration Symbols Optimizations Runtime Console Asserts Logging Profiling Defines Debug On Off Debug Visible Enabled All Disabled <code>_IE_DEBUG</code> Dev On On Release Visible Enabled All Disabled <code>_IE_DEV</code> Profiling Off On Release Visible Enabled All Enabled <code>_IE_PROFILING</code> Release Off On Release Hidden Disabled File only Disabled <code>_IE_RELEASE</code> <p>Note</p> <p>Intricate targets the <code>x86_64</code> architecture only.</p> <p>When to use each configuration:</p> <ul> <li>Debug: When you need breakpoints, stack traces, hunting memory leaks and or external debug symbols.<ul> <li>Performance in this configuration is significantly slower than in Dev and Release.</li> </ul> </li> <li>Dev: For everyday general development and testing.<ul> <li>This is the configuration that should be used for <code>98.992%</code> of development.</li> </ul> </li> <li>Profiling: When something is running unusually slow and you need to figure out which function is the culprit.<ul> <li>This configuration measures the time taken for each function to execute when called and throws the results into a series of JSON files which can be viewed in your browser's tracing tool. (e.g. <code>chrome://tracing</code> or <code>brave://tracing</code>)</li> <li>Performance in this configuration is massively slower than in all the others due to the overhead of profiling.</li> </ul> </li> <li>Release: For official distribution. (note that a <code>5th</code> configuration named \"Dist\" may be added soon)</li> </ul>"},{"location":"project/ide-requirements/","title":"IDE Requirements","text":"<p>This section specifies the Integrated Development Environment (IDE) requirements for development on Intricate.</p>"},{"location":"project/ide-requirements/#ide","title":"IDE","text":"<p>Intricate development requires Microsoft Visual Studio 2022 or newer. A secondary text editor may also be used with Visual Studio, but should not replace it. Suggested secondary text editors are:</p> <ul> <li>VS Code</li> <li>Sublime</li> <li>Vim (DOS mode)</li> <li>Neovim (DOS mode)</li> </ul> <p>.EditorConfig</p> <p>Intricate uses .editorconfig to enforce code-styling. For any other text editors, please ensure that they support .editorconfig before using them. For VS Code, this extension should be used: EditorConfig for VS Code.</p>"},{"location":"project/ide-requirements/#visual-studio-requirements","title":"Visual Studio Requirements","text":"<p>The following Visual Studio workloads are required:</p> <ul> <li>.NET desktop development</li> <li>Desktop development with C++</li> <li>Python development (optional)</li> </ul> <p>The following Visual Studio individual components are required:</p> <ul> <li>.NET<ul> <li>.NET 10.0 Runtime</li> <li>.NET SDK</li> </ul> </li> <li>Code tools<ul> <li>NuGet package manager</li> <li>NuGet targets and build tasks</li> </ul> </li> <li>Compilers, build tools, and runtimes<ul> <li>Incredibuild - Build Acceleration</li> </ul> </li> <li>SDKs, libraries and frameworks<ul> <li>Windows 11 SDK (latest)</li> <li>Windows Performance Toolkit</li> <li>Windows Universal C Runtime</li> </ul> </li> </ul> <p>Tip</p> <p>Some of the individual components listed above may already be included by the selected workloads. Ensure they are all installed in the Visual Studio Installer.</p>"},{"location":"project/ide-requirements/#recommended-vs-code-extensions","title":"Recommended VS Code Extensions","text":"<ul> <li>C/C++ Extension Pack</li> <li>C# Dev Kit</li> <li>EditorConfig for VS Code</li> <li>Lua</li> <li>Python</li> <li>Shader languages support for VS Code</li> <li>YAML</li> </ul>"},{"location":"project/setup/","title":"Setup","text":"<p>This section outlines how to setup Intricate after cloning the repository.</p>"},{"location":"project/setup/#cloning","title":"Cloning","text":"<p>Intricate must be recursively cloned to properly pull all the required submodules. Recursive cloning may be done either via the GitHub Desktop application, or with the following command:</p> <pre><code>git clone --recurse-submodules https://github.com/DnA-IntRicate/IntricateEngine\n</code></pre>"},{"location":"project/setup/#build-system","title":"Build System","text":"<p>Intricate uses Premake5 as its build system. The premake build system is configured to generate Visual Studio project and solution files off of Lua build scripts called premake files. These build scripts can be found littered around the repository and are most-commonly named <code>premake5.lua</code>.</p> <p>Example Premake file</p> <pre><code>workspace \"IntricateEngine\"\n  configurations { \"Debug\", \"Release\" }\n\nproject \"IntricateEditor\"\n  kind \"ConsoleApp\"\n  language \"C++\"\n  files { \"**.hpp\", \"**.cpp\" }\n\n  filter \"configurations:Debug\"\n      defines { \"_IE_DEBUG\" }\n      symbols \"On\"\n\n  filter \"configurations:Release\"\n      defines { \"_IE_RELEASE\" }\n      optimize \"On\"\n</code></pre>"},{"location":"project/setup/#how-to-setup","title":"How To Setup","text":"<ul> <li>Run the setup script <code>Setup.py</code>, which will validate and or install the required versions of Python, .NET and the Vulkan SDK.<ul> <li>You may have to run the script multiple times and or restart your computer as prompted by the script for all the required environment variables to be properly registered.</li> </ul> </li> <li>Once all this is done, the script will call the <code>GenerateVS.py</code> script which then uses Premake to generate all projects files targetting Visual Studio 2022.</li> </ul> <p>Required environment variables:</p> <ul> <li>Python must be added to <code>PATH</code></li> <li><code>DOTNET_ROOT</code>: path to the root of the installed .NET runtime.</li> <li><code>VULKAN_SDK</code>: path to the root of the installed Vulkan SDK.</li> <li><code>VK_SDK_PATH</code>: synonym for <code>VULKAN_SDK</code>.</li> </ul> <p>Warning</p> <p>These variables will be automatically registered by the setup script however, in the event that the script fails to register them, you will need to do so manually!</p>"},{"location":"project/system-requirements/","title":"System Requirements","text":"<p>This document outlines the minimum and recommended system specifications required to build and run Intricate.</p>"},{"location":"project/system-requirements/#supported-operating-systems","title":"Supported Operating Systems","text":"<p>Intricate only runs on Windows 10 and 11.</p>"},{"location":"project/system-requirements/#hardware-requirements","title":"Hardware Requirements","text":"Component Minimum Recommended CPU Quad-core 2.0 GHz 6+ cores, 3.0+ GHz, modern gen RAM 8 GB 16+ GB GPU Any GPU with Vulkan 1.3 support Discrete GPU with 4+ GB VRAM Storage 20 GB free disk space - Display 1080p 1440p or higher"},{"location":"project/system-requirements/#software-requirements","title":"Software Requirements","text":"<ul> <li>Git 2.5 (Windows) or newer</li> <li>GitHub Desktop</li> <li>Python 3.12 or newer</li> <li>Vulkan SDK 1.3.216</li> <li>DirectX 11 &amp; 12</li> </ul> <p>IDE requirements</p> <p>See IDE requirements for more details.</p>"},{"location":"style/comments/","title":"Comments","text":"<p>This section outlines the conventions used for writing comments in code.</p>"},{"location":"style/comments/#comment-structure","title":"Comment Structure","text":"<p>General format of a comment:</p> <pre><code>// &lt;COMMENT_TAG&gt;([optional metadata]): &lt;short imperative summary&gt;\n</code></pre> <p>Rules:</p> <ul> <li>Always include a space between the comment symbol (<code>//</code>) and the start of the comment text.</li> <li>Write comments in imperative mood to keep phrasing concise and action-oriented. (Example: <code>\"Validate session token\"</code> instead of <code>\"Validating session token\"</code> or <code>\"This validates the session token\"</code>.)</li> </ul> <p>Metadata formatting:</p> <p>When including metadata, list multiple elements as comma-separated values without spaces.</p> <p>Example:</p> <pre><code>// FIXME(Adam,medium): These allocations are leaking memory and need to be fixed!\n</code></pre>"},{"location":"style/comments/#comment-tags","title":"Comment Tags","text":"Tag Metadata Usage Example TODO author Identify work that still needs to be completed. <code>// TODO(Hasan): Pass params by const-reference here</code> FIXME author, severity(low|medium|high) Identify code known to be broken or incorrect. <code>// FIXME(Adam,medium): Need to fix this line</code> NOTE - Document reasoning, context, or non-obvious design decisions. <code>// NOTE: This field is required by the Renderer</code> INVARIANT - Document assertion conditions that must always be true. <code>// INVARIANT: Vector3 index must be in range [0,2]</code> REVIEW requested-reviewer Request a review on a specific line or block. <code>// REVIEW(Azaam): Should these fields be lazily-allocated?</code> DEPRECATED as-of-date(dd/mm/yyyy) Mark an API or function as deprecated. <code>// DEPRECATED(19/06/2025): Replaced this function with Foo()</code> WTF - Identify confusing or unexpected behavior requiring investigation. (Use sparingly.) <code>// WTF: Behavior differs between debug and release builds</code>"},{"location":"style/comments/#doxygen-guidelines","title":"Doxygen Guidelines","text":""},{"location":"style/comments/#where-to-use","title":"\ud83d\udccd Where to use?","text":"<ul> <li>At the header of every file, explaining:<ul> <li>Filename</li> <li>Brief description of file's purpose and contents.</li> <li>Author(s)</li> <li>Date of Creation</li> </ul> </li> <li>Above every Method, describing:<ul> <li>The purpose briefly, in one line</li> <li>The method in more detail. (What algorithms were used, unique decisions made.)</li> <li>The parameter(s) and result.</li> </ul> </li> <li>Class/Struct documenation:<ul> <li>Brief class description</li> <li>Detailed usage information.</li> <li>Template parameters.</li> <li>Important Member relationships</li> </ul> </li> </ul>"},{"location":"style/comments/#writing-style-guidelines","title":"Writing Style guidelines","text":"<p>Grammar &amp; Tone:</p> <ul> <li>Present tense</li> </ul> \u274c Bad <code>The function will sort the array.</code> \u2705 Good <code>Sorts the array using quicksort.</code> <ul> <li> <p>Active voice: Subject + Verb + Object</p> \u274c Bad <code>The integer is modified by the method.</code> \u2705 Good <code>The function modifies the integer.</code> </li> <li> <p>Write in Third Person instead of First Person:</p> \u274c No usage of: I, me, we. <code># I calculate the average here.</code> <code># We initialize the module</code> \u2705 Use Third person <code>Calculates the average of the values.</code><code>Initializes the communication module.</code> </li> <li> <p>Be direct and concise,</p> </li> <li> <p>Start summaries with a verb:</p> \u274c Bad <code>This function is responsible for performing the task of data validation.</code> \u2705 Good <code>Validates input data format.</code> </li> </ul>"},{"location":"style/comments/#templates","title":"TEMPLATES","text":"<p>File headers [C++ only]:</p> <pre><code>/**\n * @file    filename.cpp\n * @brief   Brief description of file purpose\n * @author  John Doe (optional)\n * @date    2024-01-15\n * \n * Detailed description of file contents, context, and usage...\n * Can span multiple lines...\n * \n * @NOTE: ...    Important notes about this file\n * @WARNING: ... Any warnings for developers\n */\n</code></pre> <p>Method Documentation:</p> <ul> <li> <p>C++:</p> <pre><code>/**\n* @brief   One-line description of function purpose\n* \n* Detailed description including algorithm, edge cases,\n* performance characteristics, etc.\n* \n* @param   param1 Description of first parameter\n* @param   param2 Description of second parameter\n* @return  Description of return value\n* /\n</code></pre> </li> <li> <p>C#:</p> <pre><code>/// &lt;summary&gt;\n/// Calculates the sum of two integers.\n/// &lt;/summary&gt;\n/// &lt;param name=\"left\"&gt;The first integer operand.&lt;/param&gt;\n/// &lt;param name=\"right\"&gt;The second integer operand.&lt;/param&gt;\n/// &lt;returns&gt;The sum of the two integers.&lt;/returns&gt;\npublic static int Add(int left, int right)\n{\n    return left + right;\n}\n</code></pre> </li> </ul> <p>Class Documentation:</p> <ul> <li> <p>C++</p> <pre><code>/**\n* @class   ClassName\n* @brief   Brief description of class purpose\n* \n* Detailed explanation of class responsibilities, usage patterns,\n* and important design decisions.\n* \n* @param  Description of template parameter requirements\n*/\npublic class ClassName&lt;T&gt;\n{\n    // Class implementation\n}\n</code></pre> </li> <li> <p>C#:</p> <pre><code>/// &lt;summary&gt;\n/// A summary about this class.\n/// &lt;/summary&gt;\n/// &lt;remarks&gt;\n/// These remarks would explain more about this class.\n/// In this example, these comments also explain the\n/// general information about the derived class.\n/// &lt;/remarks&gt;\npublic class MainClass\n{\n}\n</code></pre> </li> <li> <p>For more examples, look here: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/examples</p> </li> </ul>"},{"location":"style/comments/#discouraged-comment-styles","title":"Discouraged Comment Styles","text":"<p>Avoid the following patterns:</p> <pre><code>// This code makes no sense\n</code></pre> <pre><code>// Fix this later\n</code></pre> <p>Note</p> <p>This pattern may be used for documenting <code>private</code>/<code>internal</code> members as well as non-obvious code behavior inside methods.</p> <p>Instead, prefer tagged comments with clear, traceable meaning:</p> <pre><code>// FIXME(Muddathir,high): Investigate undefined behavior when size &lt; capacity\n</code></pre> <pre><code>// NOTE: Uses std::launder due to ABI assumptions in external library\n</code></pre>"},{"location":"style/cpp-style/","title":"C++ Style","text":"<p>This section defines stylistic, structural, and formatting standards for C++ source code.</p> <p>Naming Conventions</p> <p>Naming conventions are not covered in this section. See Naming Conventions.</p>"},{"location":"style/cpp-style/#formatting","title":"Formatting","text":"<p>Intricate uses .editorconfig to enforce code-styling. In Visual Studio, the code formatter can be run by pressing the hotkey chord <code>Ctrl+K, Ctrl+D</code> on an open file.</p> <p>Info</p> <p>All formatting rules denoted by a <code>*</code> are automatically applied by .editorconfig or Visual Studio.</p>"},{"location":"style/cpp-style/#indentation","title":"Indentation","text":"<ul> <li>Use 4 spaces per indentation level.*</li> <li>Do not use tab characters.</li> <li>Continuation lines should be indented once with respect to the current indentation level.*</li> </ul> <p>Tip</p> <p>Pressing the tab key will add 4 spaces instead of a tab character for indentation when .editorconfig is enabled.</p>"},{"location":"style/cpp-style/#line-length","title":"Line Length","text":"<ul> <li>Soft limit: 130 characters</li> <li>Split long expressions across multiple physical lines if required.</li> <li>Break long expressions at logical boundaries (e.g. in-between parameters of a method call.)</li> </ul>"},{"location":"style/cpp-style/#whitespace-and-newlines","title":"Whitespace and Newlines","text":"<ul> <li>Use exactly one blank line between:<ul> <li>Method definitions</li> <li>Class members grouped by purpose</li> <li>Logical blocks of code grouped by purpose</li> </ul> </li> <li>Do not leave trailing whitespace.*</li> <li>Use exactly one space after commas and semicolons inside parameter lists and other constructs.*</li> <li>Use exactly one space before and after binary operators.*<ul> <li>Example: <code>a + b</code>, <code>x == 3</code>, <code>value * 2</code></li> <li>No spaces for:<ul> <li>Indexing: <code>arr[i]</code></li> <li>Unary operators: <code>-x</code>, <code>!flag</code>, <code>~mask</code>, <code>++i</code>, <code>i--</code></li> <li>Scope resolution: <code>std::string</code></li> </ul> </li> </ul> </li> <li>Insert a final newline at the end of source files.*</li> </ul> <p>Warning</p> <p>More than one blank line should never be used anywhere other than in-between the <code>#include</code> directives and the namespace declaration.</p>"},{"location":"style/cpp-style/#braces","title":"Braces","text":"<ul> <li>Use the Allman style*:</li> </ul> <pre><code>void Foo()\n{\n    if (true)\n    {\n      // Block-bodies covering multiple lines must always have the opening brace on a newline.\n    }\n}\n</code></pre> <ul> <li>Omit the braces for single-line control-flow blocks:</li> </ul> <pre><code>if (true)\n    Foo();\nelse\n    Bar();\n\nif (printNumbers)\n{\n    for (int i : numbers)\n        _IE_CORE_TRACE(\"{0}\", i);\n}\n</code></pre> <ul> <li>Empty function bodies should be defined as:</li> </ul> <pre><code>void Foo() { }; // Inlined empty braces with a space in-between ended with a semicolon\n</code></pre> <ul> <li>Multi-line lambda function bodies should have their braces indented*:</li> </ul> <pre><code>Helpers::FetchExecuteIfValid&lt;Scene&gt;(nativeID, [&amp;](const Ref&lt;Scene&gt;&amp; scene)\n{\n    scene-&gt;DestroyEntity(entityID);\n});\n</code></pre>"},{"location":"style/cpp-style/#control-flow-blocks","title":"Control Flow Blocks","text":"<ul> <li>Do not inline control-flow blocks:</li> </ul> <pre><code>// Don't do this\nwhile (true) DoWork();\n\n// Do this instead\nwhile (true)\n    DoWork();\n</code></pre> <ul> <li><code>else</code>, <code>catch</code>, <code>finally</code> and <code>case</code> must always appear on its own line.</li> <li>Prefer ternary expressions over simple <code>if-else</code> blocks.</li> </ul>"},{"location":"style/cpp-style/#pointers-and-references","title":"Pointers and References","text":"<ul> <li>Place <code>*</code> and <code>&amp;</code> adjacent to the type*:</li> </ul> <pre><code>int* ptr;\nconst Foo&amp; ref;\n</code></pre> <ul> <li>Multiple declarations per line are discouraged.</li> </ul>"},{"location":"style/cpp-style/#preprocessor-directives","title":"Preprocessor Directives","text":"<ul> <li>Preprocessor directives should be indented and follow an independent indentation level:</li> </ul> <pre><code>#ifdef _IE_ENABLE_LOGGING\n#   define _IE_NATIVE_USE_TYPE_TRACKING\n#endif // _IE_ENABLE_LOGGING\n\n#ifdef _IE_NATIVE_USE_TYPE_TRACKING\n#   include &lt;IntricateEngine/Core/Core.hpp&gt;\n#endif // _IE_NATIVE_USE_TYPE_TRACKING\n</code></pre> <ul> <li>Prefer inserting ending comments to preprocessor <code>#if</code> directives as seen above.</li> </ul>"},{"location":"style/cpp-style/#file-structure","title":"File Structure","text":""},{"location":"style/cpp-style/#header-file-layout","title":"Header File Layout","text":"<ul> <li> <p>Order elements in the following sequence unless justified otherwise:</p> <ol> <li>File header, version history or copyright (if applicable)</li> <li>Header guard (<code>#pragma once</code>)</li> <li>Includes</li> <li>Module imports</li> <li>Two blank lines</li> <li>Namespace declaration</li> <li>Enum declaration(s)</li> <li>Class/struct declaration(s) (in order of dependency)     Type layout:<ol> <li>Constants</li> <li>Nested Types</li> <li>Constructors (<code>public</code> \u2192 <code>protected</code> \u2192 <code>private</code>)</li> <li>Destructor</li> <li>Public methods<ul> <li>Overrides</li> <li>Specializations</li> <li>Conversion operators</li> <li>Operator overloads</li> </ul> </li> <li>Public static constants</li> <li>Public static methods</li> <li>Protected methods</li> <li>Private methods</li> <li>Private static methods</li> <li>Instance variables (<code>public</code> \u2192 <code>protected</code> \u2192 <code>private</code>)</li> </ol> </li> </ol> </li> <li> <p>Access specifiers should be grouped and not interleaved.</p> </li> <li>Forward-declarations should be made in the appropriate scope or just before its first reference.</li> </ul>"},{"location":"style/cpp-style/#source-files","title":"Source Files","text":"<ul> <li>Order elements in the following sequence unless justified otherwise:<ol> <li>Precompiled header include</li> <li>Includes</li> <li>Module imports</li> <li>Two blank lines</li> <li>Namespace declaration</li> <li>Constants</li> <li>Nested namespaces with helpers (such as a <code>Utils</code> namespace)</li> <li>Internal global variables</li> <li>Internal methods</li> <li>Static member variable definitions</li> <li>Class/struct methods (in the order seen in the header file)</li> </ol> </li> </ul>"},{"location":"style/cpp-style/#include-directives","title":"Include Directives","text":"<ul> <li>Place <code>#include</code> directives outside of namespaces.</li> <li>Local includes should be specified using quotes: <code>#include \"MyHeader.hpp\"</code>.</li> <li>Non-local includes should be specified using angle brackets: <code>#include &lt;IntricateEngine/Math/Vector2.hpp&gt;</code>.</li> <li>Headers should always be included from top-to-bottom in terms of folder depth.</li> <li>Group and sort includes alphabetically in the following order:<ol> <li>Precompiled header/local includes</li> <li>Paired header (for a source file)</li> <li>Current project's headers</li> <li>Intricate headers</li> <li>Vendor headers</li> <li>STL headers</li> <li>C standard headers</li> <li>Platform headers (<code>d3d11.h</code>, <code>windows.h</code>, <code>sys/mman.h</code>)</li> </ol> </li> <li>Insert two blank lines after the final <code>#include</code> directive before the namespace declaration.</li> </ul>"},{"location":"style/cpp-style/#comments","title":"Comments","text":""},{"location":"style/cpp-style/#documentation","title":"Documentation","text":"<p>Use XML documentation comments for:</p> <ul> <li>Public types</li> <li>Public and protected members</li> </ul> <p>Note</p> <p>We may switch to Doxygen comments soon.</p>"},{"location":"style/cpp-style/#commenting-style","title":"Commenting Style","text":"<p>See: Comments.</p>"},{"location":"style/csharp-style/","title":"C# Style","text":"<p>This section defines stylistic, structural, and formatting standards for C# source code.</p> <p>Naming Conventions</p> <p>Naming conventions are not covered in this section. See Naming Conventions.</p>"},{"location":"style/csharp-style/#formatting","title":"Formatting","text":"<p>Intricate uses .editorconfig to enforce code-styling. In Visual Studio, the code formatter can be run by pressing the hotkey chord <code>Ctrl+K, Ctrl+D</code> on an open file.</p> <p>Info</p> <p>All formatting rules denoted by a <code>*</code> are automatically applied by .editorconfig or Visual Studio.</p>"},{"location":"style/csharp-style/#indentation","title":"Indentation","text":"<ul> <li>Use 4 spaces per indentation level.*</li> <li>Do not use tab characters.</li> <li>Continuation lines should be indented once with respect to the current indentation level.*</li> </ul> <p>Tip</p> <p>Pressing the tab key will add 4 spaces instead of a tab character for indentation when .editorconfig is enabled.</p>"},{"location":"style/csharp-style/#line-length","title":"Line Length","text":"<ul> <li>Soft limit: 130 characters</li> <li>Split long expressions across multiple physical lines if required.</li> <li>Break long expressions at logical boundaries (e.g. in-between parameters of a method call.)</li> </ul>"},{"location":"style/csharp-style/#whitespace-and-newlines","title":"Whitespace and Newlines","text":"<ul> <li>Use exactly one blank line between:<ul> <li>Method definitions</li> <li>Class members grouped by purpose</li> <li>Logical blocks of code grouped by purpose</li> </ul> </li> <li>Do not leave trailing whitespace.*</li> <li>Use exactly one space after commas and semicolons inside parameter lists and other constructs.*</li> <li>Use exactly one space before and after binary operators.*<ul> <li>Example: <code>a + b</code>, <code>x == 3</code>, <code>value * 2</code></li> <li>No spaces for:<ul> <li>Indexing: <code>arr[i]</code></li> <li>Unary operators: <code>-x</code>, <code>!flag</code>, <code>~mask</code>, <code>++i</code>, <code>i--</code></li> </ul> </li> </ul> </li> <li>Insert a final newline at the end of source files.*</li> </ul> <p>Warning</p> <p>More than one blank line should never be used anywhere other than in-between the <code>using</code> directives and the namespace declaration.</p>"},{"location":"style/csharp-style/#braces","title":"Braces","text":"<ul> <li>Use the Allman style*:</li> </ul> <pre><code>public void Foo()\n{\n    if (true)\n    {\n        // Block-bodies covering multiple lines must always have the opening brace on a newline.\n    }\n}\n</code></pre> <ul> <li>Omit the braces for single-line control-flow blocks:</li> </ul> <pre><code>if (true)\n    Foo();\nelse\n    Bar();\n\nif (printNumbers)\n{\n    foreach (int i in numbers)\n        Console.WriteLine(i);\n}\n</code></pre> <ul> <li>Empty function bodies should be defined as:</li> </ul> <pre><code>public void Foo() { } // Inlined empty braces with a space in-between\n</code></pre>"},{"location":"style/csharp-style/#control-flow-blocks","title":"Control Flow Blocks","text":"<ul> <li>Do not inline control-flow blocks:</li> </ul> <pre><code>// Don't do this\nwhile (true) DoWork();\n\n// Do this instead\nwhile (true)\n    DoWork();\n</code></pre> <ul> <li><code>else</code>, <code>catch</code>, <code>finally</code> and <code>case</code> must always appear on its own line.</li> <li>Prefer ternary expressions over simple <code>if-else</code> blocks.</li> </ul>"},{"location":"style/csharp-style/#file-structure","title":"File Structure","text":""},{"location":"style/csharp-style/#file-layout","title":"File Layout","text":"<ul> <li>Order elements in the following sequence unless justified otherwise:<ol> <li>File header, version history or copyright (if applicable)</li> <li>Using directives</li> <li>Two blank lines</li> <li>Namespace declaration</li> <li>Enum declaration(s)</li> <li>Class/struct/record/interface declaration(s) (in order of dependency)     Type layout:<ol> <li>Constants</li> <li>Nested Types</li> <li>Constructors (<code>static</code> \u2192 <code>public</code> \u2192 <code>internal</code> \u2192 <code>protected</code> \u2192 <code>private</code>)</li> <li>Destructor/Finalizer</li> <li>Public methods<ul> <li>Overrides (including <code>ToString</code>, <code>Equals</code>, <code>GetHashCode</code>)</li> <li>Interface methods</li> <li>Conversion operators</li> <li>Operator overloads</li> </ul> </li> <li>Public properties</li> <li>Public events</li> <li>Public static readonly fields</li> <li>Public static methods</li> <li>Internal/protected methods</li> <li>Private methods</li> <li>Private static methods</li> <li>Instance variables (<code>public</code> \u2192 <code>internal</code> \u2192 <code>protected</code> \u2192 <code>private</code>)</li> <li>Private properties (rare, avoid using)</li> </ol> </li> </ol> </li> </ul>"},{"location":"style/csharp-style/#using-directives","title":"Using Directives","text":"<ul> <li>Place <code>using</code> statements outside of namespaces.</li> <li>Group and sort (alphabetical):<ol> <li>Our project's namespaces</li> <li>External package/submodule namespaces</li> <li>System namespaces</li> </ol> </li> <li>Insert two blank lines after the final <code>using</code> directive before the namespace declaration.</li> </ul>"},{"location":"style/csharp-style/#comments","title":"Comments","text":""},{"location":"style/csharp-style/#documentation","title":"Documentation","text":"<p>Use XML documentation comments for:</p> <ul> <li>Public types</li> <li>Public and protected members</li> </ul> <p>Note</p> <p>We may switch to Doxygen comments soon.</p>"},{"location":"style/csharp-style/#commenting-style","title":"Commenting Style","text":"<p>See: Comments.</p>"},{"location":"style/csharp-style/#code-style","title":"Code Style","text":""},{"location":"style/csharp-style/#modifier-order","title":"Modifier Order","text":"<p>Field modifiers should appear in the following order:</p> <pre><code>// This ordering is enforced by .editorconfig and can be auto-applied from Visual Studio hints\npublic, private, protected, internal, static, extern, new, virtual, abstract, sealed, partial, override, readonly, unsafe, volatile, async\n</code></pre>"},{"location":"style/csharp-style/#expression-syntax","title":"Expression Syntax","text":"<ul> <li>Use expression-bodied members for trivial property getters and simple inline methods:</li> </ul> <pre><code>public int Count =&gt; m_Count;\n\npublic float Mass\n{\n    get =&gt; Bindings.RigidBody_GetMass(m_NativeID);\n    set =&gt; Bindings.RigidBoody_SetMass(m_NativeID, value);\n}\n\npublic bool Awake() =&gt; Bindings.RigidBody_Awake(m_NativeID);\n</code></pre> <ul> <li>Use block-bodies for everything else.</li> </ul>"},{"location":"style/csharp-style/#pattern-matching","title":"Pattern Matching","text":"<ul> <li>Favor pattern matching over explicit type casting when checking types.</li> </ul> <pre><code>public class Entity \n{ \n    /* ... */\n\n    // Explicit type casting in a block-bodied member\n    public override bool Equals(object other)\n    {\n        if (other is null)\n            return false;\n\n        if (other is not Entity)\n            return false;\n\n        return m_NativeID == ((Entity)other).m_NativeID; \n    }\n\n    // Pattern matching in an expression-bodied member\n    public override bool Equals(object other) =&gt; obj is Entity entity &amp;&amp; (m_NativeID == entity.m_NativeID);\n}\n</code></pre>"},{"location":"style/csharp-style/#immutability","title":"Immutability","text":"<ul> <li>Prefer <code>readonly</code> where applicable.</li> <li>Avoid modifying method parameters unless it's an <code>out</code> or <code>ref</code> parameter.</li> </ul>"},{"location":"style/csharp-style/#linq","title":"LINQ","text":"<ul> <li>Using LINQ is encouraged for clarity and expressiveness, but not required.</li> <li>Avoid deeply nested and \"clever\" LINQ chains - keep it readable.</li> </ul>"},{"location":"style/csharp-style/#unsafe","title":"Unsafe","text":"<ul> <li>Minimize the <code>unsafe</code> scope as far as possible.</li> <li>Avoid declaring methods and types as <code>unsafe</code>.</li> </ul> <pre><code>// Avoid declaring the method as unsafe\npublic void CopyToNative(ReadOnlySpan&lt;byte&gt; data, nint dst)\n{\n    ulong sizeBytes = data.Length; // Unsafe is not needed for this\n\n    // Rather open the unsafe block here\n    unsafe\n    {\n        fixed (byte* ptr = data)\n            Buffer.MemoryCopy(ptr, dst.ToPointer(), sizeBytes);\n    }\n}\n</code></pre> <ul> <li>Avoid passing and storing raw pointers, use <code>nint</code> instead.</li> </ul>"},{"location":"style/csharp-style/#source-control-expectations","title":"Source Control Expectations","text":"<ul> <li>Changes must adhere to this style guide.</li> <li>Automated formatting tools should be run prior to commit.</li> </ul> <p>Note</p> <p>In-future we may implement CI linting and formatting.</p>"},{"location":"style/naming-conventions/","title":"Naming Conventions","text":"<p>This section defines consistent naming rules used across all projects to improve code readability, maintainability, and predictability. These conventions apply primarily to <code>C++</code> and <code>C#</code> - and then other languages or frameworks as well, unless the specific language or framework guideline overrides them.</p>"},{"location":"style/naming-conventions/#general-principles","title":"General Principles","text":"<ul> <li>Names must be clear, descriptive, and unambiguous.</li> <li>Avoid abbreviations unless widely recognized.</li> <li>Use whole words where possible - longer more descriptive names are encouraged within reason.</li> <li>Acronyms are written in PascalCase (e.g. <code>HttpRequest</code>, not <code>HTTPRequest</code>).</li> </ul>"},{"location":"style/naming-conventions/#casing-rules","title":"Casing Rules","text":"Identifier Type Style Example Projects / Solutions PascalCase <code>IntricateEngine</code> Classes, Structs, Enums PascalCase <code>DotNetRuntime</code> Enum Values PascalCase <code>ShaderStage.Fragment</code> Functions / Methods PascalCase <code>EnqueueToMainThread</code> Variables (local) camelCase <code>frameCount</code> Parameters camelCase <code>frameCount</code> Public Member Variables PascalCase <code>FrameCount</code> Private Member Variables PascalCase + <code>m_</code> prefix <code>m_FrameCount</code> Constants UPPER_CASE <code>MAX_VERTEX_COUNT</code> Private Static Variables PascalCase + <code>s_</code> prefix <code>s_FrameCount</code> Global variables (C++) PascalCase + <code>g_</code> prefix <code>g_FrameCount</code> Internal symbols (C++) PascalCase + <code>_</code> prefix <code>_AtomicRefCount</code> Template Type Parameters (C++) PascalCase + <code>_</code> prefix <code>_Ty</code> Preprocessor directives (C++) UPPER_CASE + <code>_IE_</code> prefix <code>_IE_PROFILE_FN</code> Namespaces (C++) PascalCase <code>IntricateEngine::Interop</code> Namespaces (C#) PascalCase <code>IntricateEngine.Interop</code> Interfaces (C#) PascalCase + <code>I</code> prefix <code>IEditorPanel</code> Properties (C#) PascalCase <code>SqrMagnitude</code> Generic Type Parameters (C#) PascalCase + <code>_</code> prefix <code>_Ty</code> Internal symbols (Py) PascalCase + <code>_</code> prefix <code>_DeleteFolder</code> Source Code Files PascalCase <code>Renderer.cpp</code> Markdown Source Files kebab-case <code>naming-conventions.md</code> Folders PascalCase <code>IntricateEngine/</code> <p>Note</p> <p>C++ specfic directories, Premake files, Git artifacts and other miscellaneous config files are exempt from these naming conventions. Name according to the convention required by the relevant toolchain.</p>"},{"location":"style/naming-conventions/#boolean-naming","title":"Boolean Naming","text":"<p>Boolean function and variable names should indicate a condition or state.</p> <p>Preferred:</p> <ul> <li><code>IsVisible</code></li> <li><code>HasTransparency</code></li> <li><code>UseCache</code></li> <li><code>ShouldRebuild</code></li> </ul> <p>Avoid These:</p> <ul> <li><code>Visible</code></li> <li><code>Transparency</code></li> <li><code>Cache</code></li> <li><code>Rebuild</code></li> </ul>"},{"location":"style/naming-conventions/#functionmethod-naming","title":"Function/Method Naming","text":"<ul> <li>Functions should be action-oriented and effectively describe their behavior using verbs - even if it means that the function name may become longer.</li> <li>Avoid unreadable abbreviations!</li> </ul> Action Category Prefix Examples Function Examples Get value <code>Get</code> <code>GetTextureCount()</code> Set value <code>Set</code> <code>SetClearColor()</code> Create object <code>Create</code> <code>CreatePipeline()</code> Compute value <code>Calculate</code>, <code>Compute</code> <code>ComputeHash()</code> Validate input <code>Is</code>, <code>Has</code>, <code>Can</code> <code>IsValidPath()</code> Search object <code>Lookup</code>, <code>Fetch</code>, <code>LookupID()</code> Engine-level events <code>On</code> <code>OnKeyPressEvent()</code> Actions <code>Start</code>, <code>Update</code> <code>Start()</code> <p>Note</p> <p>These are only a small example subset of all the different possible action categories.</p>"},{"location":"style/naming-conventions/#namespace-naming","title":"Namespace Naming","text":"<ul> <li>Namespaces may be created for the subsystems that absolutely require them - which should be decided upon through team discussion.</li> <li>All new namespaces within a project must be a sub-namespace of the project's primary namespace.</li> </ul> <p>Example</p> <p><code>IntricateEngine.Interop</code> is a sub-namespace of <code>IntricateEngine</code> in the project <code>IntricateEngine.NET</code>.</p>"},{"location":"style/naming-conventions/#type-naming-classes-structs-enums-interfaces","title":"Type Naming (Classes, Structs, Enums &amp; Interfaces)","text":"<ul> <li>Class names should be nouns clearly describing what the class does and or encapsulates.</li> <li>C# Interfaces must use the <code>I</code> prefix for quick identification.</li> <li>Avoid using type names for unrelated purposes (e.g. <code>Manager</code> when no managing occurs).</li> </ul> <p>Example</p> <ul> <li><code>TextureCache</code> (noun clearly identifies what this type encapsulates)</li> <li><code>AssetManager</code> (acceptable if this type genuinely manages assets)</li> <li><code>Utils</code> (avoid this! Split responsibilities into meaningful classes)</li> </ul>"},{"location":"style/naming-conventions/#abbreviations","title":"Abbreviations","text":"<ul> <li>Allowed common abbreviations: <code>ID</code>, <code>GUID</code>, <code>URL</code>, <code>HTML</code>, <code>UI</code>, <code>GUI</code>, <code>API</code>, <code>GPU</code>, <code>CPU</code>.</li> <li>Avoid local or project-specific abbreviations unless documented or blatantly-obvious.</li> </ul> <p>Example defined abbreviations</p> <ul> <li><code>IE</code>: IntricateEngine</li> <li><code>VBO</code>: Vertex Buffer Object</li> <li><code>VK</code>: Vulkan</li> <li><code>D3D</code>: DirectX/Direct3D</li> <li><code>SRV</code>: DirectX Shader Resource View</li> <li><code>RTV</code>: DirectX Render Target View</li> </ul>"},{"location":"style/naming-conventions/#file-naming-rules","title":"File Naming Rules","text":"<ul> <li>File names should reflect the primary type or purpose.</li> <li>Use one main class or responsibility per file where practical.</li> </ul> <p>Example</p> <p>The class <code>FrameBuffer</code> belongs inside <code>FrameBuffer.cs</code>. The struct <code>FrameBufferSpecification</code> which is directly related to <code>FrameBuffer</code> also belongs inside <code>FrameBuffer.cs</code>.</p>"},{"location":"style/naming-conventions/#folder-naming-rules","title":"Folder Naming Rules","text":"<ul> <li>Folders are created for every major or minor subsystem that requires the implementation of multiple source files.</li> </ul> <p>Example</p> <p>There are many source files part of the <code>Math</code> library, therefore these files are deserving of their own folder: <code>IntricateEngine/Math/</code></p> <ul> <li>Folders should always be named in PascalCase except in instances where a certain directory tree is required to follow a different convention for a particular toolchain; such as using kebab-case folder names for web-based toolchains.</li> </ul>"},{"location":"tooling/","title":"Tooling","text":"<p>This section outlines all the various tools written for and used in Intricate.</p>"},{"location":"tooling/#code-generators","title":"Code Generators","text":"<p>Intricate currently employs <code>3</code> code generators, namely:</p> <ul> <li>BindingsGenerator: Generates C++ to C# interop glue code (or bindings) during build-time</li> <li>ImGuiCodeGenerator: Generates C# binding wrappers around cimgui and cimguizmo</li> <li>ResourceGenerator: Expresses assets/resources as C++ and C# arrays which get compiled into the project</li> </ul>"},{"location":"tooling/bindings-generator/","title":"Bindings Generator","text":"<p>This section discusses the purpose of the Bindings Generator, how it works, and how to use it.</p>"},{"location":"tooling/bindings-generator/#foreword-on-c-interop","title":"Foreword On C# Interop","text":"<p>For the interop systems to work correctly, there has to be a way for <code>C#</code> code to be able to call into <code>C++</code> code. The way we do this in Intricate, is by leveraging the LibraryImport system in C#, which is built off of the older DLLImport system.</p> <p>For <code>C#</code> to be able to call <code>C++</code> code, a LibraryImport stub method must be present in <code>C#</code>, and this stub must map to a valid exported unmangled <code>C++</code> function/symbol in a shared or static library (<code>.dll</code>/<code>.lib</code>). This combination of <code>C#</code> binding stub and <code>C++</code> binding function is referred to as a \"binding pair\".</p> <p>Example binding pair</p> <p>The <code>C#</code> binding stub:</p> <pre><code>[LibraryImport(LibIntricateEngine, EntryPoint = \"RenderCommand_GetAPI\")]\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\ninternal static partial GraphicsAPI RenderCommand_GetAPI();\n</code></pre> <p>The matching <code>C++</code> binding function:</p> <pre><code>_IE_BINDING_QUALIFIER GraphicsAPI RenderCommand_GetAPI()\n{\n    return RenderCommand::GetAPI();\n}\n</code></pre> <p>Note: <code>_IE_BINDING_QUALIFIER</code> is a macro which expands to: <code>extern \"C\" __declspec(dllexport)</code>.</p> <p>With this binding pair present and correctly written; all <code>C#</code> code that calls <code>RenderCommand_GetAPI()</code> now ultimately calls the <code>C++</code> <code>RenderCommand::GetAPI()</code> function.</p>"},{"location":"tooling/bindings-generator/#why-the-underscore-naming-convention","title":"Why the underscore naming convention?","text":"<p>In <code>C++</code>, declaring a function as <code>extern \"C\"</code> disables all name-mangling that would otherwise be performed on this function by the compiler and linker.</p> <p>Mangled vs unmangled symbols</p> <p>The mangled symbol declared without <code>extern \"C\"</code>: <code>?RenderCommand_GetAPI@Bindings@IntricateEngine@@YA?AW4GraphicsAPI@@XZ</code></p> <p>The unmangled symbol declared as <code>extern \"C\"</code>: <code>RenderCommand_GetAPI</code></p> <p>As we can see from the above example, the unmangled symbol is much easier to work with, especially since this is the name that must be set for the <code>EntryPoint</code> field in <code>C#</code>'s <code>LibraryImportAttribute</code>:</p> <pre><code>[LibraryImport(LibIntricateEngine, EntryPoint = \"RenderCommand_GetAPI\")]\n</code></pre> <p>Using unmangled symbols do however present us with a problem: all exported symbols must now be unique. This means no two functions can have the same name - including overloaded functions. This is the reason why we write binding function names in the format: <code>TypeName_FunctionName</code> - this ensures the uniqueness of the symbol.</p>"},{"location":"tooling/bindings-generator/#but-how-do-we-handle-overloads","title":"But how do we handle overloads?","text":"<p>Since all exported symbols must be unique, including overloads; we add underscore suffixes of the type names of the overloaded parameters to the binding name.</p> <p>Example</p> <p>Suppose we have <code>2</code> overloaded functions in the <code>SceneCamera</code> class:</p> <pre><code>void SetViewportSize(uint32 width, uint32 height);\nvoid SetViewportSize(Vector2Int bounds);\n</code></pre> <p>As binding function declarations (in <code>C++</code>), these would be written as:</p> <pre><code>// NOTE: For primitives, the C# type name is preferred, hence 'uint' instead of 'uint32'\n_IE_BINDING_QUALIFIER void SceneCamera_SetViewportSize_uint_uint(uint32 width, uint32 height);\n_IE_BINDING_QUALIFIER void SceneCamera_SetViewportSize_Vector2Int(Vector2Int bounds);\n</code></pre>"},{"location":"tooling/bindings-generator/#abi-requirements-calling-conventions","title":"ABI Requirements &amp; Calling Conventions","text":"<p>Note</p> <p>For the rest of this section, <code>C++</code> code will be referred to as Native code, and <code>C#</code> code will be referred to as Managed code.</p> <p>For two languages to interoperate, they must agree on the same Application Binary Interface (ABI). The ABI defines the low-level contract that both sides must follow, including the calling convention used for function calls.</p> <p>This agreement covers, among other things:</p> <ul> <li>Data layout and alignment in memory</li> <li>Which registers are used for parameters and return values</li> <li>Stack usage and stack-frame layout</li> </ul> <p>And as such, all interop binding functions we write must also adhere to ABI requirements - otherwise everything turns into undefined behaviour.</p> <p>Note</p> <p>In Intricate, on the <code>x86_64</code> platform, the Microsoft x64 ABI is used.</p>"},{"location":"tooling/bindings-generator/#plain-old-data-types-pods","title":"Plain Old Data types (PODs)","text":"<p>A type is considered a POD if:</p> <ul> <li>It is a primitive type (<code>int</code>, <code>float</code>, etc...)</li> <li>It is a struct that contains only other PODs</li> <li>It is trivially-copyable</li> <li>It defines no constructors (in <code>C++</code>)</li> </ul> <p>Tip</p> <p>Even if a <code>C++</code> struct contains only POD types and is trivially-copyable, the compiler will stop treating it as a POD the moment it sees any explicitly defined constructors. In other words, PODs may not adhere to any form of RAII.</p>"},{"location":"tooling/bindings-generator/#why-pods-matter","title":"Why PODs matter","text":"<p>PODs are very important from an ABI perspective as they don't require any explicit marshalling. This means that PODs may be directly passed as function parameters and function return-values in binding functions.</p> <p>Note</p> <p>Non-PODs may be passed as function parameters so long as the native and matching managed types have the exact same memory layout.</p> <p>In the IntricateEngine codebase, types like <code>Vector2</code> may be freely passed around in binding function parameters as it is a trivially copyable type since it only contains <code>float</code> fields - provided that the matching <code>C#</code> <code>Vector2</code> type is of the same nature with the same sequential memory layout.</p> <p>Danger</p> <p><code>Vector2</code> cannot be directly passed as a function return-value. Since <code>Vector2</code> contains explicitly-defined constructors, the compiler doesn't treat it as a POD - it is treated as a non-POD type. And when non-POD types are returned: according to the ABI, since they can't fit inside the return register, a pointer-to the return data is passed in the return register rather than the return data itself. This then leads <code>C#</code> to interpret the pointer to the data as the data itself which is very dangerous and highly incorrect.</p>"},{"location":"tooling/bindings-generator/#how-to-return-non-pods","title":"How to return non-PODs","text":"<p>Non-PODs must be returned as out pointers.</p> <p>Example</p> <p>Suppose we're writing a binding pair named <code>GetVector</code>. The <code>C#</code> binding would be written as:</p> <pre><code>[LibraryImport(LibIntricateEngine, EntryPoint = \"GetVector\")]\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\ninternal static partial void GetVector(out Vector2 vector);\n</code></pre> <p>And the <code>C++</code> binding would be written as:</p> <pre><code>_IE_BINDING_QUALIFIER void GetVector(Vector2* outVector)\n{\n    // This dereferences a pointer to managed memory and assigns it a value\n    *outVector = GetVectorFromSomewhere();\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#the-bindings-generator","title":"The Bindings Generator","text":"<p>The Bindings Generator is a code generator that automatically generates <code>C++ -&gt; C#</code> interop binding pairs during build-time. It is written in <code>C#</code> and is integrated into Premake such that it runs before <code>IntricateEngine</code> &amp; <code>IntricateEngine.NET</code> are compiled during builds. This ensures that the interop bindings are always up-to-date.</p> <p>The Bindings Generator uses a series of Interface Definition Language (IDL) files written in <code>jsonc</code> as input. The IDL schema used is as follows:</p> <pre><code>{\n    \"Metadata\": {\n        \"Type\": \"TypeName\",\n        \"Headers\": [\n            \"IntricateEngine/Header1.hpp\",\n            \"IntricateEngine/Header2.hpp\"\n        ],\n        \"Source\": \"IntricateEngine/SourceFile.cpp\"\n    },\n    \"Functions\": {\n        \"TypeName_FuncName\": {\n            \"FuncSigType\": \"FetchExecute\",\n            \"Params\": \"(void* param, NativeID objID)\",\n            \"ParamsT\": [\n                {\n                    \"Type\": \"void*\",\n                    \"Name\": \"param\"\n                },\n                {\n                    \"Type\": \"NativeID\",\n                    \"NativeType\": \"NativeObjectType\", // OPTIONAL: NativeType only needs to be defined if Type = \"NativeID\"\n                    \"Name\": \"objID\"\n                }\n            ],\n            \"Return\": \"void\"\n        },\n        // Rest of the binding functions...\n    }\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#function-signature-types","title":"Function signature types","text":"<p>The Bindings Generator emits a fixed set of native and managed function shapes depending on the ownership model, return type, and call target. The generator has a list of function signatures that are used to define the <code>FuncSigType</code> field seen in the <code>jsonc</code> schema earlier. Each function signature determines the shape of the generated binding pair.</p> <p>Warning</p> <p>It is of critical importance that the <code>FuncSigType</code> used for a particular binding pair is correct, otherwise compile-time errors and or crashes and undefined behaviour may occur.</p> <p>Note</p> <p><code>...</code> represents a placeholder for zero or more ABI-safe parameters. It does not indicate C-style variadic arguments.</p> <p>The following signatures document the canonical patterns generated by the system.</p>"},{"location":"tooling/bindings-generator/#nativeobjectcreate","title":"NativeObjectCreate","text":"<p>Used for <code>Create</code> functions when a new <code>NativeObject</code> needs to be created</p> <pre><code>_IE_BINDING_QUALIFIER uint32 TypeName_Create(...)\n{\n    return Helpers::Create&lt;_Ty&gt;(...);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#fetchexecute","title":"FetchExecute","text":"<p>Executes an instance method if the native object is valid.</p> <pre><code>_IE_BINDING_QUALIFIER void TypeName_Foo(NativeID nativeID, ...)\n{\n    Helpers::FetchExecuteIfValid&lt;TypeName&gt;(nativeID, [&amp;](const Ref&lt;TypeName&gt;&amp; x)\n    {\n        x-&gt;Foo(...);\n    });\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#fetchreturn","title":"FetchReturn","text":"<p>Executes an instance method with an ABI-safe return if the object is valid.</p> <pre><code>_IE_BINDING_QUALIFIER ReturnType TypeName_GetFunc(NativeID nativeID, ...)\n{\n    return Helpers::FetchExecuteIfValid&lt;ReturnType, TypeName&gt;(nativeID, [&amp;](const Ref&lt;TypeName&gt;&amp; x)\n    {\n        return x-&gt;GetFunc(...);\n    });\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#fetchreturnout","title":"FetchReturnOut","text":"<p>Executes an instance method with an out-pointer return if the object is valid.</p> <pre><code>_IE_BINDING_QUALIFIER void TypeName_GetFunc(NativeID nativeID, ..., ReturnType* outVal)\n{\n    *outVal = Helpers::FetchExecuteIfValid&lt;ReturnType, TypeName&gt;(nativeID, [&amp;](const Ref&lt;TypeName&gt;&amp; x)\n    {\n        return x-&gt;GetFunc(...);\n    });\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#fetchreturnoutfield","title":"FetchReturnOutField","text":"<p>Returns a pointer to a native object's field as an out-pointer return if the object is valid.</p> <pre><code>_IE_BINDING_QUALIFIER void TypeName_GetFieldNamePtr(NativeID nativeID, ReturnType** outVal)\n{\n    *outVal = Helpers::FetchExecuteIfValid&lt;ReturnType*, TypeName&gt;(nativeID, [&amp;](const Ref&lt;TypeName&gt;&amp; x)\n    {\n        return &amp;x-&gt;FieldName;\n    });\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#fetchreturnnativeobject","title":"FetchReturnNativeObject","text":"<p>Executes an instance method returning the ID to a NativeObject if this object is valid.</p> <pre><code>_IE_BINDING_QUALIFIER uint32 TypeName_GetFunc(NativeID nativeID, ...)\n{\n    return Helpers::FetchExecuteIfValid&lt;uint32, TypeName&gt;(nativeID, [&amp;](const Ref&lt;TypeName&gt;&amp; x)\n    {\n        return (uint32)x-&gt;GetFunc(...)-&gt;GetNativeID();\n    });\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#fetchreturnstring","title":"FetchReturnString","text":"<p>Executes an instance method returning a string as an ABI-safe <code>void*</code> if the object is valid.</p> <pre><code>_IE_BINDING_QUALIFIER void* TypeName_GetString(NativeID nativeID, ...)\n{\n    return Helpers::FetchExecuteIfValid&lt;void*, TypeName&gt;(nativeID, [&amp;](const Ref&lt;TypeName&gt;&amp; x)\n    {\n        return (void*)x-&gt;GetString(...).data();\n    });\n}\n</code></pre> <p>Warning</p> <p>The <code>void*</code> returned here is not stable, so managed code must copy the contents of the string into managed memory as soon as possible when using this.</p>"},{"location":"tooling/bindings-generator/#fetchreturnpinned","title":"FetchReturnPinned","text":"<p>Executes an instance method returning a complex data type that must be \"pinned\" in native heap memory to extend it's lifetime long enough for managed code to copy it.</p> <pre><code>_IE_BINDING_QUALIFIER Memory::PinnedBlock TypeName_GetFunc(NativeID nativeID, ...)\n{\n    return Memory::Pin&lt;ReturnType&gt;(Helpers::FetchExecuteIfValid&lt;ReturnType, TypeName&gt;(nativeID, [&amp;](const Ref&lt;TypeName&gt;&amp; x)\n    {\n        return x-&gt;GetFunc(...);\n    }));\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#staticexecute","title":"StaticExecute","text":"<p>Executes a static method.</p> <pre><code>_IE_BINDING_QUALIFIER void TypeName_Foo(...)\n{\n    TypeName::Foo(...);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#staticreturn","title":"StaticReturn","text":"<p>Executes a static method with an ABI-safe return.</p> <pre><code>_IE_BINDING_QUALIFIER ReturnType TypeName_Foo(...)\n{\n    return TypeName::Foo(...);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#staticreturnout","title":"StaticReturnOut","text":"<p>Executes a static method with an out-pointer return.</p> <pre><code>_IE_BINDING_QUALIFIER ReturnType TypeName_Foo(..., ReturnType* outVal)\n{\n    *outVal = TypeName::Foo(...);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#staticreturnpinned","title":"StaticReturnPinned","text":"<p>Executes a static method returning a complex data type that must be \"pinned\" in native heap memory to extend it's lifetime long enough for managed code to copy it.</p> <pre><code>_IE_BINDING_QUALIFIER Memory::PinnedBlock TypeName_Foo(...)\n{\n    return Memory::Pin&lt;ReturnType&gt;(TypeName::Foo(...));\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#singletonexecute","title":"SingletonExecute","text":"<p>Executes a static method on a singleton.</p> <pre><code>_IE_BINDING_QUALIFIER void TypeName_Foo(...)\n{\n    TypeName::Get().Foo(...);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#singletonreturn","title":"SingletonReturn","text":"<p>Executes a static method on a singleton with an ABI-safe return.</p> <pre><code>_IE_BINDING_QUALIFIER ReturnType TypeName_Foo(...)\n{\n    return TypeName::Get().Foo(...);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#singletonreturnpinned","title":"SingletonReturnPinned","text":"<p>Executes a static method on a singleton returning a complex data type that must be \"pinned\" in native heap memory to extend it's lifetime long enough for managed code to copy it.</p> <pre><code>_IE_BINDING_QUALIFIER Memory::PinnedBlock TypeName_Foo(...)\n{\n    return Memory::Pin(TypeName::Get().Foo(...));\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#pointercastexecute","title":"PointerCastExecute","text":"<p>Executes an instance method on a raw <code>this</code> pointer passed from managed code.</p> <pre><code>_IE_BINDING_QUALIFIER void TypeName_Foo(void* ptr, ...)\n{\n    _IE_CORE_ASSERT(ptr, \"ptr from managed was null!\");\n    (static_cast&lt;TypeName*&gt;(ptr))-&gt;Foo(...);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#pointercastreturn","title":"PointerCastReturn","text":"<p>Executes an instance method with an ABI-safe return on a raw <code>this</code> pointer passed from managed code.</p> <pre><code>_IE_BINDING_QUALIFIER ReturnType TypeName_Foo(void* ptr, ...)\n{\n    _IE_CORE_ASSERT(ptr, \"ptr from managed was null!\");\n    return (static_cast&lt;TypeName*&gt;(ptr))-&gt;Foo(...);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#ecsgetnativeobject","title":"EcsGetNativeObject","text":"<p>Returns the ID to a NativeObject field of a component part of the entity-component-system.</p> <pre><code>_IE_BINDING_QUALIFIER uint32 ComponentName_GetFieldName(NativeID sceneID, uint32 entityID)\n{\n    return Helpers::GetComponentNativeObjectField&lt;ComponentName, TypeName, &amp;ComponentName::FieldName&gt;(sceneID, entityID);\n}\n</code></pre> <p>Note</p> <p>The <code>FieldName</code> must be the same as the <code>TypeName</code> here.</p>"},{"location":"tooling/bindings-generator/#ecsgetfield","title":"EcsGetField","text":"<p>Returns an ABI-safe field of a component part of the entity-component-system.</p> <pre><code>_IE_BINDING_QUALIFIER ReturnType ComponentName_GetFieldName(NativeID sceneID, uint32 entityID)\n{\n    return Helpers::GetComponentField&lt;ComponentName, ReturnType, &amp;ComponentName::FieldName&gt;(sceneID, entityID);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#ecsgetoutfield","title":"EcsGetOutField","text":"<p>Returns a field of a component part of the entity-component-system as an out-pointer.</p> <pre><code>_IE_BINDING_QUALIFIER void ComponentName_GetFieldName(NativeID sceneID, uint32 entityID, ReturnType* outVal)\n{\n    Helpers::GetComponentField&lt;ComponentName, ReturnType, &amp;ComponentName::FieldName&gt;(sceneID, entityID, outVal);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#ecsgetstringfield","title":"EcsGetStringField","text":"<p>Returns a string field of a component part of the entity-component-system as an out-void-pointer.</p> <pre><code>_IE_BINDING_QUALIFIER void ComponentName_GetFieldName(NativeID sceneID, uint32 entityID, void** outStrPtr)\n{\n    Helpers::GetComponentField&lt;ComponentName, std::string, &amp;ComponentName::FieldName&gt;(sceneID, entityID, outStrPtr);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#ecssetfield","title":"EcsSetField","text":"<p>Sets an ABI-safe field of a component part of the entity-component-system.</p> <pre><code>_IE_BINDING_QUALIFIER void ComponentName_SetFieldName(NativeID sceneID, uint32 entityID, TypeName val)\n{\n    Helpers::SetComponentField&lt;ComponentName, TypeName, &amp;ComponentName::FieldName&gt;(sceneID, entityID, val);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#ecssetstringfield","title":"EcsSetStringField","text":"<p>Sets a string field of a component part of the entity-component-system.</p> <pre><code>_IE_BINDING_QUALIFIER void ComponentName_SetFieldName(NativeID sceneID, uint32 entityID, ManagedUTF8String val)\n{\n    Helpers::SetComponentField&lt;ComponentName, std::string, &amp;ComponentName::FieldName&gt;(sceneID, entityID, val);\n}\n</code></pre>"},{"location":"tooling/bindings-generator/#macroexecute","title":"MacroExecute","text":"<p>Executes functionality defined in a <code>C++</code> macro.</p> <pre><code>_IE_BINDING_QUALIFIER void TypeName_Foo(...)\n{\n    _IE_FOO(...);\n}\n</code></pre>"}]}